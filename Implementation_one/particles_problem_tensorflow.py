# -*- coding: utf-8 -*-
"""particles_problem_tensorflow.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1y4niCmTENhJryY_pOjoP4wu2bEGsa-of
"""

import tensorflow as tf
import numpy as np

"""### Load Files to tensorflow Variables
### Declare a few tensorflow Constants
"""

# load data from .npy files
mass = tf.Variable(np.load('masses.npy'), dtype=tf.float64)
positions = tf.Variable(np.load('positions.npy'),dtype=tf.float64)
velocities = tf.Variable(np.load('velocities.npy'),dtype=tf.float64)
# Declaring some constants
G = tf.constant(667000,dtype=tf.float64)
flag = tf.Variable(0,dtype=tf.float64)
threshold = tf.constant(0.1,dtype=tf.float64)
delta_t = tf.constant(0.0001,dtype=tf.float64)
num = tf.constant(100, dtype=tf.float64)

"""### Complete Mathematical model
### The full Computational Graph Data Flow Structure
"""

positions_x = positions[:, 0] # r_x
positions_y = positions[:, 1] # r_y

#difference Matrices in X and Y
diff_pos_x = tf.cast(tf.transpose([positions_x]) - positions_x, dtype=tf.float64)
diff_pos_y = tf.cast(tf.transpose([positions_y]) - positions_y, dtype=tf.float64)

#squared difference Matrices in X and Y
sq_diff_pos_x = tf.cast(tf.square(diff_pos_x), dtype=tf.float64)
sq_diff_pos_y = tf.cast(tf.square(diff_pos_y), dtype=tf.float64)

#displacement matrix
disp = tf.sqrt(tf.add(sq_diff_pos_x,sq_diff_pos_y))

#setting the diagonal elements equal to 1
#disp = tf.matrix_set_diag(disp, tf.ones(num))

#define an identity matrix
Identity = tf.eye(num_rows=100,num_columns=100,dtype=tf.float64)  #Arguments follow nice keyword semantics

#Add Identity to disp to make its diagonal elements equal to one
disp = tf.add(Identity,disp)

#Threshold checking function
check = tf.cond(tf.size(tf.where(tf.less_equal(disp, threshold))) > 0, lambda: tf.assign(flag, 1), lambda: tf.assign(flag, 0))

#Taking reciprocal of disp
disp = tf.reciprocal(disp)

#Multiply with G and cubing disp Matrix
disp = tf.cast(G*tf.pow(disp,3), dtype=tf.float64)

#changing diagonal value to zero
disp = tf.subtract(disp,Identity)


#displacement reciprocal multiplied elementwise with difference matrices
disp_x = tf.multiply(disp, diff_pos_x)
disp_y = tf.multiply(disp, diff_pos_y)

#Calculating acceleration using post matrix multiplication with mass vector
accel_x = tf.matmul(disp_x, tf.reshape(mass, [tf.size(mass), 1]))
accel_y = tf.matmul(disp_y, tf.reshape(mass, [tf.size(mass), 1]))

#Reshaping the accelerations in both directions
accel_x = tf.reshape(accel_x, [tf.size(accel_x), 1])
accel_y = tf.reshape(accel_y, [tf.size(accel_y), 1])


#The complete acceleration matrix by concatenating the two obtained vectors
acc = tf.concat([accel_x, accel_y], 1)

#Operation to update the positions and velocities
update_positions = tf.assign(positions, positions + delta_t * velocities + (1 / 2) * (delta_t ** 2) * acc) # update the value of positions
update_velocities = tf.assign(velocities, velocities + delta_t * acc) # update the values of velocities

"""### The Session part to run the Data-flow Computational graph"""

sess = tf.Session()
sess.run(tf.global_variables_initializer())  #Initializing all the Variables
threshold_val = 0
count = 0
while(threshold_val == 0):
  threshold_val = sess.run(check)
  new_positions , new_velocities = sess.run([update_positions, update_velocities])
  count +=1
  print("Iteration number:")
  print(count)
  print("flag Value:")
  print(threshold_val)
print(new_positions, new_velocities)
np.savetxt('final_positions.npy',new_positions)
np.savetxt('final.velocities.npy',new_velocities)